# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account {
  address: ID
  assets: [Asset!]
  auctions: [Auction!]
  cover: String
  description: String
  followers(pagination: ConnectionArgs): FollowerResponse
  following(pagination: ConnectionArgs): FollowerResponse
  herotag: String
  orders: [Order!]
  profile: String
  socialLinks: [SocialLink!]
}

type AccountEdge {
  cursor: String
  node: Account
}

type AccountPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type AccountResponse {
  edges: [AccountEdge!]
  pageData: PageData
  pageInfo: AccountPageInfo
}

input AccountsFilter {
  addresses: [String!]!
}

input AddLikeArgs {
  identifier: String!
}

type Asset {
  attributes: String!
  auctions: [Auction!]
  balance: String
  collection: ID!
  creationDate: Int
  creator: Account
  creatorAddress: String!
  hasAvailableAuctions: Boolean
  hash: String
  identifier: String!
  isLiked(byAddress: String!): Boolean
  likesCount: Int
  lowestAuction: Auction
  metadata: Metadata
  name: String
  nonce: Int!
  owner: Account
  ownerAddress: String
  royalties: String!
  supply: String!
  tags: [String!]
  thumbnailUrl: String
  totalAvailableTokens: String
  totalRunningAuctions: String
  type: NftTypeEnum
  uris: [String!]!
  url: String
}

enum AssetActionEnum {
  Added
  Bought
  ClosedAuction
  Created
  EndedAuction
  Received
  StartedAuction
}

type AssetEdge {
  cursor: String
  node: Asset
}

input AssetHistoryFilter {
  identifier: String!
}

type AssetHistoryLog {
  account: Account
  action: AssetActionEnum!
  actionDate: Int!
  address: String!
  itemCount: String
  price: Price
  senderAccount: Account
  senderAddress: String
  transactionHash: String!
}

type AssetHistoryLogEdge {
  cursor: String
  node: AssetHistoryLog
}

type AssetHistoryLogPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type AssetHistoryLogResponse {
  edges: [AssetHistoryLogEdge!]
  pageData: PageData
  pageInfo: AssetHistoryLogPageInfo
}

type AssetPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input AssetsFilter {
  collection: String
  creatorAddress: String
  identifier: String
  likedByAddress: String
  ownerAddress: String
  tags: [String!]
  type: NftTypeEnum
}

type AssetsResponse {
  edges: [AssetEdge!]
  pageData: PageData
  pageInfo: AssetPageInfo
}

input AttributeInput {
  description: String!
  tags: [String!]!
}

type Auction {
  asset: Asset
  availableTokens: Int
  collection: String!
  creationDate: Int!
  endDate: Int!
  id: ID!
  identifier: String!
  maxBid: Price!
  minBid: Price!
  nonce: Int!
  nrAuctionedTokens: Int
  orders: [Order!]
  owner: Account
  ownerAddress: String
  startDate: Int!
  status: AuctionStatusEnum
  tags: String
  topBid: Price
  topBidder: Account
  type: AuctionTypeEnum
}

type AuctionEdge {
  cursor: String
  node: Auction
}

type AuctionPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type AuctionResponse {
  edges: [AuctionEdge!]
  pageData: PageData
  pageInfo: AuctionPageInfo
}

enum AuctionStatusEnum {
  Closed
  Ended
  None
  Running
}

enum AuctionTypeEnum {
  Nft
  None
  SftAll
  SftOnePerPayment
}

input BidActionArgs {
  auctionId: Int!
  identifier: String!
  price: String!
}

input BuySftActionArgs {
  auctionId: Int!
  identifier: String!
  price: String!
  quantity: String
}

type Collection {
  canAddQuantity: Boolean
  canBurn: Boolean
  canCreate: Boolean
  canFreeze: Boolean
  canPause: Boolean
  canTransferRole: Boolean
  canWipe: Boolean
  collection: String
  collectionAsset: CollectionAsset!
  creationDate: Float!
  name: String!
  owner: Account
  ownerAddress: String
  ticker: String!
  type: String
}

type CollectionAsset {
  assets: [CollectionAssetModel]
  totalCount: String
}

type CollectionAssetModel {
  identifier: String!
  thumbnailUrl: String
}

type CollectionEdge {
  cursor: String
  node: Collection
}

type CollectionPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type CollectionResponse {
  edges: [CollectionEdge!]
  pageData: PageData
  pageInfo: CollectionPageInfo
}

input CollectionsFilter {
  """Flag for can create or not on collection"""
  canCreate: Boolean

  """Collection identifier"""
  collection: String

  """The user that has create role"""
  creatorAddress: String

  """The owner of the collection"""
  ownerAddress: String
  type: NftTypeEnum
}

input ConnectionArgs {
  """Paginate after opaque cursor"""
  after: String

  """Paginate before opaque cursor"""
  before: String

  """Paginate first"""
  first: Int = 10

  """Paginate last"""
  last: Int
}

input CreateAuctionArgs {
  deadline: String!
  identifier: String!
  maxBid: String
  maxOneSftPerPayment: Boolean
  minBid: String!
  paymentToken: String!
  paymentTokenNonce: Int
  quantity: String = "1"
  startDate: String
}

input CreateNftArgs {
  attributes: AttributeInput!
  collection: String!
  name: String!
  quantity: String = "1"
  royalties: String = "0"
}

input Filter {
  field: String!
  op: Operation!
  values: [String!]!
}

input FiltersExpression {
  filters: [Filter!]!
  operator: Operator!
}

input FollowEntityArgs {
  addressToFollow: String!
}

type FollowerResponse {
  edges: [FollowerResponseEdge!]
  pageData: PageData
  pageInfo: PageInfo
}

type FollowerResponseEdge {
  cursor: String!
  node: Account
}

enum GroupBy {
  IDENTIFIER
}

input Grouping {
  groupBy: GroupBy!
}

input HandleQuantityArgs {
  addOrBurnRoleAddress: String!
  identifier: String!
  quantity: String!
}

input HistoryPagination {
  """Paginate first"""
  first: Int = 10

  """Timestamp from where to start"""
  timestamp: Int
}

input IssueCollectionArgs {
  canFreeze: Boolean = false
  canPause: Boolean = false
  canTransferNFTCreateRole: Boolean = false
  canWipe: Boolean = false
  tokenName: String!
  tokenTicker: String!
}

type Metadata {
  description: String!
  fileName: String!
  fileType: String!
  fileUri: String!
}

type Mutation {
  addLike(input: AddLikeArgs!): Boolean!
  addSftQuantity(input: HandleQuantityArgs!): TransactionNode!
  bid(input: BidActionArgs!): TransactionNode!
  burnQuantity(input: HandleQuantityArgs!): TransactionNode!
  buySft(input: BuySftActionArgs!): TransactionNode!
  createAuction(input: CreateAuctionArgs!): TransactionNode!
  createNft(file: Upload!, input: CreateNftArgs!): TransactionNode!
  endAuction(auctionId: Int!): TransactionNode!
  follow(input: FollowEntityArgs!): Boolean!
  issueNftCollection(input: IssueCollectionArgs!): TransactionNode!
  issueSftCollection(input: IssueCollectionArgs!): TransactionNode!
  removeLike(input: RemoveLikeArgs!): Boolean!
  setRoles(input: SetNftRolesArgs!): TransactionNode!
  stopNftCreate(input: StopNftCreateArgs!): TransactionNode!
  transferNft(input: TransferNftArgs!): TransactionNode!
  transferNftCreateRole(input: TransferNftCreateRoleArgs!): TransactionNode!
  unfollow(input: UnfollowEntityArgs!): Boolean!
  withdraw(auctionId: Int!): TransactionNode!
}

enum NftTypeEnum {
  NonFungibleESDT
  SemiFungibleESDT
}

enum Operation {
  BETWEEN
  EQ
  GE
  IN
  LE
  LIKE
}

enum Operator {
  AND
  OR
}

type Order {
  auction: Auction
  auctionId: Int!
  boughtTokensNo: String
  creationDate: Int
  endDate: Int
  from: Account
  id: ID!
  ownerAddress: String!
  price: Price!
  status: OrderStatusEnum!
}

type OrderEdge {
  cursor: String
  node: Order
}

type OrderPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum OrderStatusEnum {
  active
  inactive
}

type OrdersResponse {
  edges: [OrderEdge!]
  pageData: PageData
  pageInfo: OrderPageInfo
}

type Owner {
  account: Account
  address: String
  balance: String
  identifier: ID
}

type OwnerEdge {
  cursor: String
  node: Owner
}

type OwnerPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type OwnerResponse {
  edges: [OwnerEdge!]
  pageData: PageData
  pageInfo: OwnerPageInfo
}

input OwnersFilters {
  identifier: String!
}

type PageData {
  count: Int!
  limit: Int!
  offset: Int!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Price {
  amount: String!
  nonce: Int!
  timestamp: Int!
  token: ID!
  usdAmount: String
}

type Query {
  accounts(filters: AccountsFilter!, pagination: ConnectionArgs): AccountResponse!
  assetHistory(filters: AssetHistoryFilter!, pagination: HistoryPagination): AssetHistoryLogResponse!
  assets(filters: AssetsFilter, pagination: ConnectionArgs): AssetsResponse!
  auctions(filters: FiltersExpression, grouping: Grouping, pagination: ConnectionArgs, sorting: [Sorting!]): AuctionResponse!
  auctionsSortByBids(filters: FiltersExpression, grouping: Grouping, pagination: ConnectionArgs): AuctionResponse!
  collections(filters: CollectionsFilter, pagination: ConnectionArgs): CollectionResponse!
  featuredNfts(pagination: ConnectionArgs): AssetsResponse!
  myClaimableAuctions(pagination: ConnectionArgs): AuctionResponse!
  orders(filters: FiltersExpression, pagination: ConnectionArgs, sorting: [Sorting!]): OrdersResponse!
  owners(filters: OwnersFilters!, pagination: ConnectionArgs): OwnerResponse!
  trendingAuctions(
    """This should be a timestamp"""
    endDate: Int!
    pagination: ConnectionArgs

    """This should be a timestamp"""
    startDate: Int!
  ): AuctionResponse!
}

input RemoveLikeArgs {
  identifier: String!
}

input SetNftRolesArgs {
  addressToTransfer: String!
  collection: String!
  roles: [String!]!
}

type SocialLink {
  type: ID
  url: String
}

enum Sort {
  ASC
  DESC
}

input Sorting {
  direction: Sort!
  field: String!
}

input StopNftCreateArgs {
  collection: String!
  ownerAddress: String!
}

type TransactionNode {
  chainID: String!
  data: String!
  gasLimit: Float!
  gasPrice: Float!
  nonce: Int!
  options: String!
  receiver: String!
  sender: String!
  status: String!
  value: String!
  version: Float!
}

input TransferNftArgs {
  destinationAddress: String!
  identifier: String!
  quantity: String = "1"
}

input TransferNftCreateRoleArgs {
  addressToTransferList: [String!]!
  collection: String!
  ownerAddress: String!
}

input UnfollowEntityArgs {
  addressToUnfollow: String!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload
